**Hooks are the backbone of modern React (v16.8+)**.

# What are Hooks in React?

**Hooks are special functions that let you “hook into” React’s features inside functional components.**
Before hooks, these features (like state, lifecycle methods) were only available in **class components**.

With hooks:

- You can use **state** in functional components (`useState`).
- You can use **lifecycle-like effects** (`useEffect`).
- You can **reuse logic** without rewriting components.

---

# Why Hooks Were Introduced

Before hooks:

- We had to use **class components** to manage state/lifecycle.
- Functional components were just “dumb UI renderers”.
- Code reuse was messy (HOCs, render props).

Hooks solved this by:

1. Making functional components powerful (state + lifecycle).
2. Reducing boilerplate.
3. Making code **easier to read, test, and reuse**.

---

# Rules of Hooks

1.  **Only call hooks at the top level**

- Don’t use hooks inside loops, conditions, or nested functions.
- This ensures React can track hook order correctly.

2.  **Only call hooks from React functions**

- Functional components.
- Custom hooks.
- Not inside regular JS functions.

---

# Commonly Used React Hooks

### 1. **`useState`**

- Adds **state** to functional components.

```jsx
const [count, setCount] = useState(0);
```

---

### 2. **`useEffect`**

- Handles **side effects** (like fetching data, setting timers, subscriptions).

```jsx
useEffect(() => {
  console.log("Component mounted or updated");
  return () => console.log("Cleanup on unmount");
}, []);
```

---

### 3. **`useContext`**

- Consumes values from **Context API** (avoids prop drilling).

```jsx
const user = useContext(UserContext);
```

---

### 4. **`useReducer`**

- Alternative to `useState` for **complex state logic**.

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

---

### 5. **`useRef`**

- Stores **mutable values** that don’t cause re-renders.
- Also used to directly access DOM elements.

```jsx
const inputRef = useRef();
<input ref={inputRef} />;
```

---

### 6. **`useMemo`**

- Memoizes expensive calculations to improve performance.

```jsx
const memoizedValue = useMemo(() => expensiveCalc(num), [num]);
```

---

### 7. **`useCallback`**

- Memoizes functions to avoid unnecessary re-renders.

```jsx
const memoizedFn = useCallback(() => doSomething(a, b), [a, b]);
```

---

### 8. **`useLayoutEffect`**

- Similar to `useEffect`, but runs **synchronously after DOM updates**.
- Used when you need to measure DOM before browser paints.

---

### 9. **`useImperativeHandle`**

- Customizes what’s exposed when using `ref` with `forwardRef`.

---

### 10. **`useTransition`, `useDeferredValue`** (React 18 concurrent features)

- Helps with **UI responsiveness** during heavy updates.

---

# Custom Hooks

You can create **your own hooks** to reuse logic.
Example: `useFetch` hook for API calls.

```jsx
import { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then((data) => setData(data));
  }, [url]);

  return data;
}

export default useFetch;
```

Usage:

```jsx
const users = useFetch("https://jsonplaceholder.typicode.com/users");
```

---

# Advantages of Hooks

Simpler than class components.
Better **code reuse** (via custom hooks).
No need to remember `this`.
Smaller, more focused components.
Enable **functional programming style**.

---

# Summary

- **Hooks are functions** that let you use React features (state, effects, context, refs, performance optimizations) inside functional components.
- **Basic hooks**: `useState`, `useEffect`, `useContext`.
- **Advanced hooks**: `useReducer`, `useMemo`, `useCallback`, `useRef`.
- **Custom hooks**: let you reuse logic between components.
