# `useReducer` Hook in React

---

## 1. **What is `useReducer`?**

- A React hook for **state management inside a component**.
- Alternative to `useState`.
- Useful when:

  - State logic is complex (multiple sub-values).
  - State updates depend on previous state.
  - Multiple actions update state in different ways.

üëâ Think of it like **Redux, but scoped to one component**.

---

## 2. **Syntax**

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

- `state` ‚Üí current state value.
- `dispatch(action)` ‚Üí function to trigger an update.
- `reducer(state, action)` ‚Üí pure function that defines **how state changes**.
- `initialState` ‚Üí starting state.

---

## 3. **Basic Example: Counter**

```jsx
import React, { useReducer } from "react";

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h2>Count: {state.count}</h2>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </div>
  );
}

export default Counter;
```

Instead of `setCount()`, we use `dispatch({ type: "increment" })`.

---

## 4. **Why `useReducer` Instead of `useState`?**

- `useState` ‚Üí best for **simple state** (numbers, strings, booleans, small objects).
- `useReducer` ‚Üí better when:

  1. State has **multiple properties**.
  2. Multiple actions update state differently.
  3. Updates depend on **previous state**.
  4. You want a **clearer structure** (action types, reducers).

---

## 5. **Complex Example: Form State**

Imagine a form with multiple inputs:

```jsx
import React, { useReducer } from "react";

const initialState = { name: "", email: "", age: "" };

function reducer(state, action) {
  switch (action.type) {
    case "CHANGE_INPUT":
      return { ...state, [action.field]: action.value };
    case "RESET":
      return initialState;
    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  const handleChange = (e) => {
    dispatch({
      type: "CHANGE_INPUT",
      field: e.target.name,
      value: e.target.value,
    });
  };

  return (
    <form>
      <input
        name="name"
        value={state.name}
        onChange={handleChange}
        placeholder="Name"
      />
      <input
        name="email"
        value={state.email}
        onChange={handleChange}
        placeholder="Email"
      />
      <input
        name="age"
        value={state.age}
        onChange={handleChange}
        placeholder="Age"
      />
      <button type="button" onClick={() => dispatch({ type: "RESET" })}>
        Reset
      </button>
      <pre>{JSON.stringify(state, null, 2)}</pre>
    </form>
  );
}

export default Form;
```

Much cleaner than multiple `useState` calls.

---

## 6. **Lazy Initialization with useReducer**

Like `useState`, you can **initialize state lazily**:

```jsx
function init(initialCount) {
  return { count: initialCount };
}

const [state, dispatch] = useReducer(reducer, 0, init);
```

---

## 7. **Advantages of `useReducer`**

1. **Better for complex state** ‚Üí organized state management.
2. **Predictable updates** ‚Üí actions & reducers make logic clear.
3. **Scales well** ‚Üí similar to Redux structure.
4. **Easier testing** ‚Üí reducer is just a pure function.

---

## 8. **Disadvantages of `useReducer`**

1. **More boilerplate** than `useState`.
2. **Overkill** for simple state (like toggles, counters).
3. Can get complex if misused ‚Üí sometimes Redux or Zustand is better.

---

## 9. **When to Use `useReducer`**

- Forms with multiple fields.

- Complex UI state (e.g., modal open/close, tabs, filters).

- When state transitions follow **clear actions**.

- When you want **Redux-like structure** without Redux.

- Don‚Äôt use if state is simple ‚Üí `useState` is easier.

---

## 10. **Industry Perspective**

- Developers often use `useReducer` for **component-level state** (forms, filters).
- For **global state**, they prefer **Redux Toolkit or Zustand**.
- But `useReducer` is a **great learning bridge** ‚Üí helps you understand how Redux works (reducers, actions, dispatch).

---

# Key Takeaways

- **useState** ‚Üí Simple state (1‚Äì2 values).
- **useReducer** ‚Üí Complex local state (multiple values, multiple update actions).
- **Context + useReducer** ‚Üí A mini Redux-like state management system.
- **Redux Toolkit** ‚Üí Full global state management solution.

## <!-- ********************************************************************* -->

Understanding the **flow of `useReducer`** is the key to really mastering it.

---

# The Flow of `useReducer`

x
`useReducer` is like a mini state management system inside React.
It has **4 main parts working together**:

1. **Initial State** ‚Äì your starting data.
2. **Reducer Function** ‚Äì decides how state should change.
3. **Dispatch Function** ‚Äì sends an ‚Äúaction‚Äù (a message).
4. **Action Object** ‚Äì describes _what happened_.

Together, these replace the simple `setState`.

---

## Flow Diagram

```
UI Event (button click)
      ‚Üì
  dispatch(action)  ‚Üê‚Äì "I want to do this"
      ‚Üì
reducer(state, action) ‚Üê‚Äì "How should state change?"
      ‚Üì
 new state returned
      ‚Üì
 React re-renders component with updated state
```

---

## Example: Counter with `useReducer`

```jsx
import React, { useReducer } from "react";

// 1Ô∏è‚É£ Initial state
const initialState = { count: 0 };

// 2Ô∏è‚É£ Reducer function
function reducer(state, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    case "DECREMENT":
      return { count: state.count - 1 };
    case "RESET":
      return { count: 0 };
    default:
      return state;
  }
}

function Counter() {
  // 3Ô∏è‚É£ Hook setup: gives us state and dispatch
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h2>Count: {state.count}</h2>
      {/* 4Ô∏è‚É£ Dispatching actions */}
      <button onClick={() => dispatch({ type: "INCREMENT" })}>+1</button>
      <button onClick={() => dispatch({ type: "DECREMENT" })}>-1</button>
      <button onClick={() => dispatch({ type: "RESET" })}>Reset</button>
    </div>
  );
}

export default Counter;
```

---

# Role of Each Component in the Flow

### 1. **Initial State**

- The **starting point** of your state.
- Example: `{ count: 0 }`, `{ cart: [] }`, `{ user: null }`.
- Passed as the **second argument** in `useReducer(reducer, initialState)`.

---

### 2. **Reducer Function**

- A **pure function**: `(state, action) => newState`.
- Decides **how state should change** based on action type.
- Must **always return new state** (never mutate directly).
- Example:

  ```js
  function reducer(state, action) {
    switch (action.type) {
      case "INCREMENT":
        return { count: state.count + 1 };
      case "RESET":
        return { count: 0 };
      default:
        return state;
    }
  }
  ```

---

### 3. **Dispatch Function**

- Comes from `useReducer`.
- Used to **send actions** to reducer.
- When you call `dispatch(action)`, React runs the reducer with the current state + action, and then re-renders.
- Example:

  ```js
  dispatch({ type: "INCREMENT" });
  ```

---

### 4. **Action Object**

- A plain object describing _what happened_.
- Has at least a `type` (string).
- Can also carry extra `payload` (data).
- Example:

  ```js
  { type: "ADD_ITEM", payload: { id: 1, name: "Book" } }
  ```

---

# Putting It Together (Step by Step)

1. **Render first time** ‚Üí `useReducer` initializes state with `initialState`.
2. **User clicks button** ‚Üí `dispatch({ type: "INCREMENT" })`.
3. **React calls reducer** ‚Üí `reducer(currentState, action)`.
4. **Reducer returns new state** ‚Üí `{ count: 1 }`.
5. **React re-renders** component with updated state.

---

**Big Picture**:

- `useState` = update directly (`setState`).
- `useReducer` = update indirectly by describing **what happened** (`dispatch(action)`), and letting the **reducer decide how to handle it**.

<!-- ************************************************************** -->

# Why Use `useReducer` if `useState` Can Do the Job?

Yes, you can absolutely do **increment, decrement, reset** with `useState`. But `useReducer` shines in situations where **state logic becomes more complex or structured**.

---

## 1. **useState Recap**

- Simple: manage one piece of state directly.
- You just call `setState(newValue)` whenever you need to update.
- Perfect for: counters, toggles, form inputs, etc.

Example with `useState`:

```jsx
const [count, setCount] = useState(0);

<button onClick={() => setCount(count + 1)}>Increment</button>
<button onClick={() => setCount(count - 1)}>Decrement</button>
<button onClick={() => setCount(0)}>Reset</button>
```

---

## 2. **useReducer Recap**

- Designed for **more complex state logic**.
- You define:
  - **State** (current values).
  - **Actions** (what you want to do).
  - **Reducer** (function that decides how state changes).
- You dispatch actions instead of directly setting state.

Example with `useReducer`:

```jsx
const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    case "DECREMENT":
      return { count: state.count - 1 };
    case "RESET":
      return { count: 0 };
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(reducer, initialState);

<button onClick={() => dispatch({ type: "INCREMENT" })}>Increment</button>
<button onClick={() => dispatch({ type: "DECREMENT" })}>Decrement</button>
<button onClick={() => dispatch({ type: "RESET" })}>Reset</button>
```

---

## 3. **Key Differences**

| Feature            | `useState`                               | `useReducer`                                                   |
| ------------------ | ---------------------------------------- | -------------------------------------------------------------- |
| **When to use**    | Simple, independent states               | Complex, interdependent states                                 |
| **State updates**  | Direct (`setCount(count + 1)`)           | Via `dispatch(action)`                                         |
| **Logic location** | Inlined in event handlers                | Centralized inside reducer                                     |
| **Scalability**    | Hard to manage when many states interact | Easier to manage structured updates                            |
| **Debugging**      | Harder to track changes                  | Clear action history (esp. with devtools if extended to Redux) |

---

## 4. **When `useReducer` is Better**

- **Complex state logic** ‚Üí e.g. multiple conditions, nested state objects.
- **Interdependent state updates** ‚Üí when one state depends on another.
- **Centralized state management** ‚Üí logic stays in one place (the reducer).
- **Predictability** ‚Üí each action describes exactly what happened.

Example: a form state with multiple fields üëá

### With `useState` (messy when fields increase):

```jsx
const [name, setName] = useState("");
const [email, setEmail] = useState("");
const [age, setAge] = useState("");

function handleName(e) {
  setName(e.target.value);
}
function handleEmail(e) {
  setEmail(e.target.value);
}
function handleAge(e) {
  setAge(e.target.value);
}
```

### With `useReducer` (cleaner):

```jsx
const initialState = { name: "", email: "", age: "" };

function reducer(state, action) {
  switch (action.type) {
    case "SET_FIELD":
      return { ...state, [action.field]: action.value };
    case "RESET":
      return initialState;
    default:
      return state;
  }
}

const [state, dispatch] = useReducer(reducer, initialState);

<input value={state.name} onChange={(e) => dispatch({ type: "SET_FIELD", field: "name", value: e.target.value })} />
<input value={state.email} onChange={(e) => dispatch({ type: "SET_FIELD", field: "email", value: e.target.value })} />
<input value={state.age} onChange={(e) => dispatch({ type: "SET_FIELD", field: "age", value: e.target.value })} />
<button onClick={() => dispatch({ type: "RESET" })}>Reset</button>
```

üëâ Here, `useReducer` scales better because all state update logic is centralized.

---

## 5. **Extra Things `useReducer` Provides**

1. **Centralized logic** ‚Üí easier to test, debug, maintain.
2. **Scalability** ‚Üí handles multiple related states together.
3. **Readability** ‚Üí clear "actions" instead of scattered `setState`.
4. **Closer to Redux pattern** ‚Üí makes migration easier if app grows.
5. **Predictable updates** ‚Üí state transitions are well-defined.

---

**Conclusion:**

- Use `useState` for **simple, independent states**.
- Use `useReducer` for **complex, related state logic** (like forms, shopping cart, authentication flows).

---

<!-- ********************************************************************* -->

Let‚Äôs take a **realistic example**: a **shopping cart**

We‚Äôll implement **Add Item, Remove Item, Clear Cart** first with `useState` and then with `useReducer` so you can compare.

---

# 1. Shopping Cart with `useState`

```jsx
import React, { useState } from "react";

function CartUseState() {
  const [cart, setCart] = useState([]);

  const addItem = (item) => {
    setCart([...cart, item]);
  };

  const removeItem = (id) => {
    setCart(cart.filter((item) => item.id !== id));
  };

  const clearCart = () => {
    setCart([]);
  };

  return (
    <div>
      <h2> Cart (useState)</h2>
      <button
        onClick={() => addItem({ id: Date.now(), name: "Item " + Date.now() })}
      >
        Add Item
      </button>
      <button onClick={clearCart}>Clear Cart</button>

      <ul>
        {cart.map((item) => (
          <li key={item.id}>
            {item.name}
            <button onClick={() => removeItem(item.id)}> Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default CartUseState;
```

Works fine, but notice:

- `setCart([...])` logic is spread across different functions.
- As features grow (like update quantity, discounts, etc.), this will get messy.

---

# 2. Shopping Cart with `useReducer`

```jsx
import React, { useReducer } from "react";

const initialState = [];

function reducer(state, action) {
  switch (action.type) {
    case "ADD_ITEM":
      return [...state, action.payload];
    case "REMOVE_ITEM":
      return state.filter((item) => item.id !== action.id);
    case "CLEAR_CART":
      return [];
    default:
      return state;
  }
}

function CartUseReducer() {
  const [cart, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <h2> Cart (useReducer)</h2>
      <button
        onClick={() =>
          dispatch({
            type: "ADD_ITEM",
            payload: { id: Date.now(), name: "Item " + Date.now() },
          })
        }
      >
        Add Item
      </button>
      <button onClick={() => dispatch({ type: "CLEAR_CART" })}>
        Clear Cart
      </button>

      <ul>
        {cart.map((item) => (
          <li key={item.id}>
            {item.name}
            <button
              onClick={() => dispatch({ type: "REMOVE_ITEM", id: item.id })}
            >
              Remove
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default CartUseReducer;
```

Differences here:

- All **state logic is centralized** in the `reducer` function.
- Components don‚Äôt care _how_ state is updated, they just dispatch actions.
- Adding new logic (like `"UPDATE_QUANTITY"`) is easy ‚Üí just add a new case in reducer.

---

# Side-by-Side Comparison

| Aspect             | `useState`                                  | `useReducer`                     |
| ------------------ | ------------------------------------------- | -------------------------------- |
| **Logic location** | Spread across multiple `setState` functions | Centralized in `reducer`         |
| **Scalability**    | Gets messy as state logic grows             | Easier to add new actions        |
| **Readability**    | Event handlers contain update logic         | Handlers just `dispatch` actions |
| **Best for**       | Simple apps (toggle, counter, form inputs)  | Complex apps (cart, forms, auth) |

---

**Takeaway:**

- For small things ‚Üí `useState` is simpler.
- For larger, evolving state with many operations ‚Üí `useReducer` is cleaner and scalable.
