# ðŸ”¹ Context API in React

---

## 1. **What is Context API?**

- Context API is a **built-in React feature** that lets you share data across the component tree **without prop drilling**.
- Introduced in React 16.3.
- Think of it as a **global state container** for your React app, but simpler than Redux.

---

## 2. **Why Do We Need Context API?**

### The Problem â†’ Prop Drilling

```jsx
<App>
  <Navbar>
    <UserMenu>
      <Profile>
        <Avatar /> // Needs user data
      </Profile>
    </UserMenu>
  </Navbar>
</App>
```

- If `App` has user data, but `Avatar` needs it â†’ youâ€™d pass it down through all components as props.
- Even components that donâ€™t need it (`Navbar`, `UserMenu`) must pass it.
- This is **prop drilling** â†’ messy, hard to maintain, and causes unnecessary re-renders.

  **Solution â†’ Context API**: store the data at a higher level and let deeply nested components consume it directly.

---

## 3. **How Context API Works (Step by Step)**

### Step 1: Create Context

```jsx
import { createContext } from "react";

export const UserContext = createContext();
```

### Step 2: Provide Context (wrap with Provider)

```jsx
import React, { useState } from "react";
import { UserContext } from "./UserContext";
import Profile from "./Profile";

function App() {
  const [user, setUser] = useState({ name: "John", age: 25 });

  return (
    <UserContext.Provider value={user}>
      <Profile />
    </UserContext.Provider>
  );
}

export default App;
```

### Step 3: Consume Context (useContext Hook)

```jsx
import React, { useContext } from "react";
import { UserContext } from "./UserContext";

function Profile() {
  const user = useContext(UserContext);

  return <h2>Hello, {user.name}!</h2>;
}

export default Profile;
```

Now, any nested component can access `user` directly â†’ no prop drilling.

---

## 4. **Advantages of Context API**

1. **Solves Prop Drilling** â€“ Share data globally without passing props down many levels.
2. **Built into React** â€“ No extra library (like Redux) needed.
3. **Simple API** â€“ Easy to set up (`createContext`, `Provider`, `useContext`).
4. **Great for Low-Frequency State** â€“ Auth, theme, language.
5. **Scoped Contexts** â€“ You can create multiple contexts (AuthContext, ThemeContext, etc.).

---

## 5. **Disadvantages of Context API**

1. **Re-render Performance Issues**

   - When context value changes, **all consumers re-render**, even if they donâ€™t use the changed property.
   - Can cause unnecessary re-renders in large apps.

2. **Not a Replacement for State Management Libraries**

   - Fine for small apps.
   - For **large, complex, frequently updated state** â†’ Redux Toolkit or Zustand is better.

3. **Debugging**

   - No devtools (unlike Redux).
   - Harder to track state changes across app.

4. **Overuse Can Be Bad**

   - Using Context for every piece of state makes app structure confusing.
   - Should be used **strategically** (auth, theme, language).

---

## 6. **Best Use Cases for Context API**

- **Authentication** â†’ user login state across app.
- **Theme** â†’ dark/light mode.
- **Language (i18n)** â†’ translation strings.
- **Global Settings** â†’ feature flags, app-wide configs.
- **Shopping Cart (small app)** â†’ cart state shared across components.

**Not Good For:**

- Large, frequently changing state (API data, complex forms, large lists).
- Where performance optimization and debugging are critical â†’ use Redux Toolkit + React Query instead.

---

## 7. **Context API with Performance Optimization**

If you need to optimize:

- Split large contexts into smaller ones (AuthContext, ThemeContext).
- Use **memoization**:

```jsx
<UserContext.Provider value={useMemo(() => user, [user])}>
  <Profile />
</UserContext.Provider>
```

- Or use **selector patterns** with libraries like `use-context-selector` to avoid re-renders.

---

## 8. **Industry Practices**

- Small apps: `useState` + Context API is enough.
- Medium apps: Context API for **auth + theme**, and Redux Toolkit for **app state**.
- Large apps: Redux Toolkit + React Query â†’ Context only for config/auth.

---

## 9. **Comparison with Redux Toolkit**

| Feature           | Context API             | Redux Toolkit               |
| ----------------- | ----------------------- | --------------------------- |
| Setup             | Easy                    | Moderate                    |
| Prop Drilling Fix | Yes                     | Yes                         |
| DevTools Support  | No                      | Yes                         |
| Performance       | Risky                   | Optimized                   |
| Async Logic       | Manual                  | Built-in (Thunk, RTK Query) |
| Use Cases         | Small apps, auth, theme | Mediumâ€“Large apps           |

---

# Key Takeaways

- **What:** Context API = Reactâ€™s built-in way to share global data.
- **Why:** Solves prop drilling.
- **How:** `createContext â†’ Provider â†’ useContext`.
- **Advantages:** Simple, no external library, great for global config.
- **Disadvantages:** Performance issues, no devtools, not for big apps.
- **Use Cases:** Auth, theme, language, app settings.

---

The best way to **understand the need for Context API**.
Weâ€™ll build a simple **User Profile app**.

---

# Version 1: With Prop Drilling (Problem)

Here, the **App** has user data â†’ passed down through multiple components â†’ until it reaches the deeply nested `Avatar`.

```jsx
// App.js
import React, { useState } from "react";
import Navbar from "./Navbar";

function App() {
  const [user] = useState({ name: "John Doe", email: "john@example.com" });

  return (
    <div>
      <h1>Prop Drilling Example</h1>
      {/* Passing user down to Navbar */}
      <Navbar user={user} />
    </div>
  );
}

export default App;
```

```jsx
// Navbar.js
import React from "react";
import UserMenu from "./UserMenu";

function Navbar({ user }) {
  return (
    <nav style={{ background: "#eee", padding: "10px" }}>
      <h2>My App</h2>
      {/* Passing user down to UserMenu */}
      <UserMenu user={user} />
    </nav>
  );
}

export default Navbar;
```

```jsx
// UserMenu.js
import React from "react";
import Profile from "./Profile";

function UserMenu({ user }) {
  return (
    <div>
      <p>Menu</p>
      {/* Passing user down to Profile */}
      <Profile user={user} />
    </div>
  );
}

export default UserMenu;
```

```jsx
// Profile.js
import React from "react";
import Avatar from "./Avatar";

function Profile({ user }) {
  return (
    <div>
      <h3>Profile Section</h3>
      {/* Passing user down to Avatar */}
      <Avatar user={user} />
    </div>
  );
}

export default Profile;
```

```jsx
// Avatar.js
import React from "react";

function Avatar({ user }) {
  return (
    <div>
      <h4>Avatar Component</h4>
      <p>Name: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}

export default Avatar;
```

---

### The Problem:

- `App â†’ Navbar â†’ UserMenu â†’ Profile â†’ Avatar`
- Each level passes `user` even if it doesnâ€™t use it.
- As app grows, this becomes **unmanageable**.

---

# Version 2: Refactored with Context API (Solution)

Now weâ€™ll use **Context API** to remove prop drilling.

---

### Step 1: Create Context

```jsx
// UserContext.js
import { createContext } from "react";

export const UserContext = createContext();
```

---

### Step 2: Provide Context in App

```jsx
// App.js
import React, { useState } from "react";
import Navbar from "./Navbar";
import { UserContext } from "./UserContext";

function App() {
  const [user] = useState({ name: "John Doe", email: "john@example.com" });

  return (
    <UserContext.Provider value={user}>
      <div>
        <h1>Context API Example</h1>
        <Navbar />
      </div>
    </UserContext.Provider>
  );
}

export default App;
```

---

### Step 3: Consume Context Anywhere

No need to pass `user` through props anymore

```jsx
// Navbar.js
import React from "react";
import UserMenu from "./UserMenu";

function Navbar() {
  return (
    <nav style={{ background: "#eee", padding: "10px" }}>
      <h2>My App</h2>
      <UserMenu />
    </nav>
  );
}

export default Navbar;
```

```jsx
// UserMenu.js
import React from "react";
import Profile from "./Profile";

function UserMenu() {
  return (
    <div>
      <p>Menu</p>
      <Profile />
    </div>
  );
}

export default UserMenu;
```

```jsx
// Profile.js
import React from "react";
import Avatar from "./Avatar";

function Profile() {
  return (
    <div>
      <h3>Profile Section</h3>
      <Avatar />
    </div>
  );
}

export default Profile;
```

```jsx
// Avatar.js
import React, { useContext } from "react";
import { UserContext } from "./UserContext";

function Avatar() {
  const user = useContext(UserContext);

  return (
    <div>
      <h4>Avatar Component</h4>
      <p>Name: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}

export default Avatar;
```

---

# Result

- In **prop drilling version**, every component passed `user`.
- In **context version**, only `App` provides the data â†’ `Avatar` consumes it directly.
- Cleaner, scalable, and easier to maintain.

---

At first glance, **Context API looks like just a fancy way to pass props** and avoid prop drilling. But let me expand on it, because **Context API is indeed part of state management in React** (just not as powerful as Redux, Zustand, etc.).

---

# ðŸ”¹ How Context API is State Management

### 1. **What is State Management in React?**

State management = _how you create, read, update, and share state across components_.

- Local state â†’ `useState`, `useReducer` (inside one component).
- Shared/global state â†’ Context API, Redux, Zustand, React Query, etc.

  **Context API provides a way to share state globally.**

---

### 2. **Not Just Passing Props**

While it _looks_ like "just avoiding prop drilling", it can actually:

- **Hold global state** (not only static values).
- **Update state globally** from any component.

Example: Authentication

```jsx
// UserContext.js
import { createContext } from "react";
export const UserContext = createContext();
```

```jsx
// App.js
import React, { useState } from "react";
import { UserContext } from "./UserContext";
import Navbar from "./Navbar";

function App() {
  const [user, setUser] = useState(null);

  const login = () => setUser({ name: "John", role: "Admin" });
  const logout = () => setUser(null);

  return (
    <UserContext.Provider value={{ user, login, logout }}>
      <div>
        <h1>Context API with State</h1>
        <Navbar />
      </div>
    </UserContext.Provider>
  );
}

export default App;
```

```jsx
// Navbar.js
import React, { useContext } from "react";
import { UserContext } from "./UserContext";

function Navbar() {
  const { user, login, logout } = useContext(UserContext);

  return (
    <nav>
      {user ? (
        <>
          <p>Welcome {user.name}</p>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <button onClick={login}>Login</button>
      )}
    </nav>
  );
}

export default Navbar;
```

Now, **any component** can:

- Access `user` state.
- Call `login()` or `logout()` â†’ updating state globally.

This is **state management**: creating, updating, and sharing state across the app.

---

### 3. **What Context API Can Do (in State Management terms)**

- Store global state (auth, theme, language).
- Provide updater functions (`setState`) globally.
- Let any component read or modify state without prop drilling.
- Doesnâ€™t provide structure for large/complex state.
- Doesnâ€™t optimize performance (re-renders all consumers).
- Doesnâ€™t include async state management (API calls, caching, etc.).

---

### 4. **Advantages of Context API for State Management**

- Simpler than Redux/Zustand.
- No external dependencies.
- Perfect for **low-frequency global state** (auth, theme, language).

---

### 5. **Limitations**

- Becomes messy if you manage **a lot of state** with Context.
- Frequent updates â†’ cause performance issues (all consumers re-render).
- No built-in debugging tools (unlike Redux devtools).

Thatâ€™s why **in industry**, Context is often used **alongside Redux Toolkit or React Query**:

- Context â†’ Auth, theme, config (global but low update).
- Redux Toolkit â†’ Complex client state (cart, dashboard filters).
- React Query â†’ Server state (API data).

---

# Final Takeaway

- **Context API is indeed state management** â€” it lets you share + update state globally.
- Itâ€™s **best suited for small-to-medium global state** (auth, theme, language).
- For **large-scale apps with complex logic**, we use **Redux Toolkit, Zustand, or React Query** instead.

---
